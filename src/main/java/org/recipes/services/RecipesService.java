package org.recipes.services;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;

import org.recipes.dto.IngredientDTO;
import org.recipes.dto.RecipeDTO;
import org.recipes.dto.RecipeUsesIngredientDTO;
import org.recipes.dto.UserDTO;
import org.recipes.model.Recipe;
import org.recipes.model.RecipeUsesIngredient;
import org.recipes.model.User;
import org.springframework.stereotype.Service;

@Service
public class RecipesService {

	EntityManagerFactory emf = Persistence.createEntityManagerFactory("Recipes");
	
	public RecipeDTO getRecipe(Integer id) {
		EntityManager em = emf.createEntityManager();
		Recipe recipe = em.find(Recipe.class,id);
		return new RecipeDTO(recipe,true);
	}
	public List<RecipeDTO> getMyRecipes(UserDTO user){
		
		EntityManager em = emf.createEntityManager();
		TypedQuery<Recipe> query = em.createNamedQuery("Recipe.myRecipes", Recipe.class);			
		User entityUser = user.constructUserEntity();
		query.setParameter("owner", entityUser);
		List<Recipe> myRecipes = query.getResultList();
		List<RecipeDTO> results = new ArrayList<RecipeDTO>();
		for (Recipe recipe : myRecipes){
			recipe.getRecipeUsesIngredients(); //??
			results.add(new RecipeDTO(recipe,true));
		}
		return results;
	}
	
	public void deleteRecipe(UserDTO user, Integer recipeId) {
		//first verify that the user owns the recipe		
		EntityManager em = emf.createEntityManager();						 
		CriteriaBuilder builder = em.getCriteriaBuilder();		
		Recipe recipeEntity = em.find(Recipe.class, recipeId);
		if (!recipeEntity.getUser().getId().equals(user.getId())){		
			throw new IllegalArgumentException ("User " + user.getId() + " does not own recipe " + recipeEntity.getTitle());
	  	}else {
			em.getTransaction().begin();		
			em.remove(recipeEntity);
			em.getTransaction().commit();	
	  	}
	}
	
	public RecipeDTO createOrModifyRecipe(UserDTO user, RecipeDTO recipeForm) {
		EntityManager em = emf.createEntityManager();
		if (recipeForm.getId() != null) {
			//first verify that the user owns the recipe
			Recipe recipeEntity = em.find(Recipe.class, recipeForm.getId());			
		  	if (!recipeEntity.getUser().getId().equals(user.getId())) {
		  		throw new IllegalArgumentException ("User " + user.getId() + " does not own the recipe " + recipeForm.getTitle());
		  	}
		}
		recipeForm.setUser(user);
	  	Recipe RecipeEntity = recipeForm.constructEntity();
		em.getTransaction().begin();		
		RecipeEntity = em.merge(RecipeEntity);
		em.persist(RecipeEntity);		 
		em.getTransaction().commit();	
	  	RecipeDTO result = new RecipeDTO(RecipeEntity);
	  	return result;
	  			
	}
	
	
	public List<RecipeDTO> analyzeIngredients(IngredientDTO[] ingredients, int tolerance){
		EntityManager em = emf.createEntityManager();
		TypedQuery<Recipe> query = em.createNamedQuery("Recipe.findAll", Recipe.class);
		List<Recipe> allRecipes = query.getResultList();
		List<Recipe> matchingRecipes = new ArrayList<Recipe>();
		for (Recipe checkRecipe : allRecipes) {
			//how many ingredients are in checkRecipe and not in ingredients
			int numMissingIngredients=0;
			for (RecipeUsesIngredient rui : checkRecipe.getRecipeUsesIngredients()) {
				boolean isInRecipe = true;
				boolean isInIngredients = false;
				for (IngredientDTO checkIngredient : ingredients) {
					if (checkIngredient.getId().equals(rui.getIngredient().getId())) {
						isInIngredients = true;
					}
				}
				if (isInRecipe && ! isInIngredients) {
					numMissingIngredients ++;
				}
			}
			if (numMissingIngredients <= tolerance && checkRecipe.getRecipeUsesIngredients().size() > 0) {
				matchingRecipes.add(checkRecipe);
			}
		}
		List<RecipeDTO> results = new ArrayList<RecipeDTO>();
		for (Recipe recipe : matchingRecipes) {
			results.add(new RecipeDTO(recipe));
		}
		return results;
	}
	
	public List<RecipeDTO> analyzeRecipes(RecipeDTO[] recipes){
		EntityManager em = emf.createEntityManager();
   		TypedQuery<Recipe> query = em.createNamedQuery("Recipe.findAll", Recipe.class);
		List<Recipe> allRecipes = query.getResultList();
		List<RecipeDTO> results = new ArrayList<RecipeDTO>();
	
		//get the set of unique ingredients referenced by the list of recipes
		Set<IngredientDTO> ingredients = new HashSet<IngredientDTO>();
		for (RecipeDTO recipeForm : recipes) {
			for (RecipeUsesIngredientDTO rui : recipeForm.getRecipeUsesIngredients()) {
				ingredients.add(rui.getIngredient());
			}
		}
		
		/**
		 * Find all recipes such that 80% of that recipes ingredient list is found in the ingredient list generated by the
		 * given set of recipes.  
		 */
		for (Recipe checkRecipe: allRecipes) {			
			if (checkRecipe.getRecipeUsesIngredients().size() == 0) {
				continue;
			}
			int numIngredientsMatch = 0;
			//exclude those recipes that are in the original set of selected recipes
			boolean isDuplicate = false;
			for (RecipeDTO innerCheck : recipes) {
				if (innerCheck.getId().equals(checkRecipe.getId())) {
					isDuplicate = true;
					break; //exit inner for loop
				}
			}
			
			if (isDuplicate) {
				/*At this point, we know we don't want this recipe in the results regardless of its ingredients, 
				 * so continue on to the next recipe
				 */
				continue; 
			}
			for (RecipeUsesIngredient rui : checkRecipe.getRecipeUsesIngredients()) {
				boolean found = false;
				for (IngredientDTO checkIngredient : ingredients) {
					if (checkIngredient.getId().equals(rui.getIngredient().getId())) {
						found = true;
						break; //exit inner for loop
					}
				}
				if (found) {
					numIngredientsMatch++;
				}
			}
			Double ratio = (double)numIngredientsMatch / (double)checkRecipe.getRecipeUsesIngredients().size();
			//TODO: MAGIC NUMBERS
			Double threshold = new Double(0.8D);
			if (ratio.compareTo(threshold) >= 0) {
				RecipeDTO returnRecipe = new RecipeDTO(checkRecipe,true);
				results.add(returnRecipe);				
			}			
		}
		return results;
	}
	

}
